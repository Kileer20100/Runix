## **От хаоса к порядку — пишем наш первый драйвер**

В прошлый раз мы совершили чудо: заставили компьютер запускать наш собственный код. На экране появилось гордое **«Runix Kernel v0.1.0»**. Но если заглянуть внутрь, то наш успех был, скажем так, _минималистичным_.

Мы написали вот такой код:
```rust
let vga_buffer = 0xb8000 as *mut u8;
unsafe {
    *vga_buffer.offset(i as isize * 2) = byte;
    *vga_buffer.offset(i as isize * 2 + 1) = 0x0B;
}
```
И он работал! Но давайте признаем: это был **хаос**. Мы напрямую колдовали с памятью, разбросали `unsafe` по всему коду, а сам процесс вывода был хрупким и неудобным. Это как собрать двигатель на коленке, скрепив детали изолентой — работает, но ехать далеко на таком страшно.

**Проблемы нашего «прототипа»:**

1. **Опасно:** Одна ошибка в расчёте индекса — и мы портим память ядра.
    
2. **Неудобно:** Хотите вывести число? Придётся вручную конвертировать его в строку и снова плясать с указателями.
    
3. **Неподдерживаемо:** Добавьте сюда цвет, прокрутку или поддержку `\n` — и код превратится в лапшу.
    
4. **Не Rust-way:** Мы игнорируем главные суперсилы языка — систему типов и безопасность.
    

### **Что мы сделаем сегодня**

Сегодня мы превратим этот хаотичный прототип в **настоящий, архитектурно чистый драйвер**. Мы пройдём путь от сырых указателей до безопасных, переиспользуемых абстракций. Наша цель — не просто «заставить работать», а **заложить фундамент**, на котором будут строиться все остальные компоненты Runix.

**Вот план:**

1. **Разберёмся с железом:** Кратко вспомним, как VGA-контроллер показывает текст (80x25, по 2 байта на символ).
    
2. **Спроектируем архитектуру:** Придумаем, как упаковать работу с видеопамятью в удобную «чёрную коробку» с безопасным интерфейсом.
    
3. **Напишем код, который не стыдно показать:** Реализуем буферизацию, цвета, управляющие символы (`\n`, `\t`) и даже макрос `println!`, как в стандартной библиотеке.
    
4. **Проанализируем и улучшим:** Посмотрим на готовый код, найдём слабые места и подумаем, как его можно развивать дальше.
    

**Философия этого урока:** В системном программировании `unsafe` — это не запрещённый приём, а **строительный материал**. Наша задача — спрятать его внутрь прочных, надёжных абстракций, чтобы весь остальной код жил в мире гарантий Rust.

Если в прошлый раз мы _включили_ компьютер, то сегодня мы дадим ему **голос**. Поехали!
## **Введение**

После успешной загрузки минимального ядра Runix перед нами стоит важная задача: обеспечить взаимодействие системы с пользователем. В условиях отсутствия графического интерфейса основным способом вывода информации становится текстовый режим. Для архитектуры x86_64 стандартом де-факто является VGA (Video Graphics Array) — аппаратный стандарт, поддерживающий текстовый режим 80×25 символов.

Создание драйвера VGA — это первый и критически важный шаг в развитии операционной системы. Этот драйвер не только позволяет выводить информацию на экран, но и служит фундаментом для отладки всех последующих компонентов системы.

## **Что такое драйвер в контексте ОС?**

Драйвер — это программный компонент, который предоставляет абстрактный интерфейс для работы с конкретным аппаратным устройством. В случае VGA драйвера, его задача — скрыть сложность работы с видеоконтроллером и предоставить простые функции для вывода текста.

## **Аппаратные основы VGA**

### **Текстовый режим VGA**

- Разрешение: 80 колонок × 25 строк
    
- Каждый символ занимает 2 байта в видеопамяти:
    
    - Байт 0: ASCII код символа
        
    - Байт 1: Атрибуты (цвет текста и фона)
        
- Видеопамять начинается с физического адреса `0xb8000`
    
- Поддерживает 16 цветов текста и 16 цветов фона
    

### **Цветовая палитра VGA**

VGA использует 4-битное кодирование цвета, где:

- Младшие 4 бита (0-3): цвет текста
    
- Старшие 4 бита (4-7): цвет фона

## **Архитектура драйвера VGA в Runix**

### **1. Инкапсуляция состояния**

Вместо работы с разрозненными глобальными переменными, мы создаём структуру `VgaState`, которая содержит всё необходимое состояние драйвера:

```rust
struct VgaState {
    screen_text: [u8; 25 * 80],  // Буфер символов
    screen_color: [u8; 25 * 80], // Буфер цветов
    row: usize,                  // Текущая строка
    col: usize,                  // Текущая колонка
    write_color: u8,             // Текущий цвет вывода
}
```
**Преимущества:**

- Все связанные данные в одном месте
    
- Проще управлять, тестировать и отлаживать
    
- Чёткая граница ответственности
### **2. Синхронизация доступа**

В многозадачной среде ядра несколько потоков или обработчиков прерываний могут одновременно пытаться выводить информацию на экран. Для предотвращения конфликтов используется мьютекс (mutual exclusion):

```rust
static STATE: Mutex<VgaState> = Mutex::new(VgaState::new());
```
`Mutex` гарантирует, что только один поток в данный момент может изменять состояние VGA драйвера.

### **3. Двойная буферизация**

Прямая запись в видеопамять для каждого символа вызывает мерцание и неэффективна. Решение — двойная буферизация:

1. Все операции записи сначала выполняются в буферы в оперативной памяти
    
2. По мере необходимости (или по запросу) содержимое буферов копируется в видеопамять
    

**Преимущества:**

- Устранение мерцания при выводе
    
- Возможность сложных операций (прокрутка, частичное обновление)
    
- Более эффективное использование видеопамяти

## **Реализация интерфейса вывода**

### **Интеграция с системой форматирования Rust**

Одно из ключевых решений — реализация трейта `Write` из модуля `core::fmt`:

```rust
impl Write for VGAPrinter {
    fn write_str(&mut self, text: &str) -> core::fmt::Result {
        let mut state = STATE.lock();
        for byte in text.bytes() {
            match byte {
                b'\n' => state.next_line(),
                b'\r' => state.first_line(),
                b'\t' => state.tab(),
                32..=126 => state.main_write_char(byte),
                _ => {}
            }
        }
        Ok(())
    }
}
```
### **Макросы для удобного использования**

Для предоставления привычного интерфейса создаются макросы:

```rust
#[macro_export]
macro_rules! println {
    ($($arg:tt)*) => {
        $crate::drivers::vga::xd8000::println::println(format_args!($($arg)*));
    };
}
#[macro_export]
macro_rules! println_warn {
    ($($arg:tt)*) => {
        $crate::drivers::vga::xd8000::println::println_warn(format_args!($($arg)*));
    };
}
#[macro_export]
macro_rules! println_error {
    ($($arg:tt)*) => {
        $crate::drivers::vga::xd8000::println::println_error(format_args!($($arg)*));
    };
}
```
Макросы позволяют писать код в стиле стандартной библиотеки Rust, что повышает читаемость и снижает порог входа для разработчиков.
Обработка управляющих символов

Драйвер VGA должен корректно обрабатывать не только печатаемые символы, но и управляющие:

    \n (новая строка) — переход на следующую строку

    \r (возврат каретки) — возврат к началу текущей строки

    \t (табуляция) — переход к следующей позиции табуляции

    \b (backspace) — возврат на один символ (в будущих версиях)
## **Демонстрация работы цветовых макросов**
![[Demonstration_color_macros.png]]
## Код вызова макросов
```rust
println_error!("\nRunix Error: {}", 0);
println_warn!("\n\tRunix Warn: {}", 1);
println!("\r{} v0.1.0", "Runix Kernel");
```
## **Построчный разбор:**

### **1. Первая строка:**

```rust
println_error!("\nRunix Error: {}", 0);
```

**Что делает:**

- `println_error!` — макрос для вывода ошибок (красный текст)
    
- `"\nRunix Error: {}"` — строка с двумя частями:
    
    - `\n` — управляющий символ "новая строка"
        
    - `{}` — placeholder для аргумента форматирования
        
- `0` — значение, которое подставится вместо `{}`
    

**Как работает:**

1. Создаётся новая строка (курсор перемещается на начало следующей строки)
    
2. Выводится красный текст "Runix Error: 0"
    

### **2. Вторая строка:**

```rust
println_warn!("\n\tRunix Warn: {}", 1);
```

**Что делает:**

- `println_warn!` — макрос для предупреждений (жёлтый текст)
    
- `"\t\nRunix Warn: {}"` — строка с:
    
    - `\t` — табуляция (переход на следующую позицию, кратную 4)
        
    - `\n` — новая строка
        
    - `{}` — placeholder
        
- `1` — значение для подстановки
    

**Как работает:**

1. Табуляция (курсор сдвигается на 4 позиции вправо)
    
2. Новая строка (курсор в начало следующей строки)
    
3. Выводится жёлтый текст "Runix Warn: 1"
    

### **3. Третья строка:**

```rust
println!("\r{} v0.1.0", "Runix Kernel");
```

**Что делает:**

- `println!` — стандартный макрос (белый текст)
    
- `"\r{} v0.1.0"` — строка с:
    
    - `\r` — возврат каретки (курсор в начало буфера)
        
    - `{}` — placeholder
        
- `"Runix Kernel"` — строка для подстановки
    

**Как работает:**

1. Возврат каретки (курсор перемещается в начало буфера)
    
2. Выводится белый текст "Runix Kernel v0.1.0" **поверх предыдущего текста в этой строке**
# **Детальный анализ реализации VgaState**

## **Конструктор `new()`**

```rust
const fn new() -> Self {
    Self {
        screen_text: [0; 25 * 80],
        screen_color: [0; 25 * 80],
        row: 0,
        col: 0,
        write_color: Color::WHITE,
    }
}
```

**Что делает:**
- Создаёт новый экземпляр `VgaState` с инициализированными значениями
- Буферы текста и цветов заполняются нулями
- Курсор устанавливается в позицию (0, 0) — верхний левый угол
- Цвет по умолчанию — белый

**Особенность:** `const fn` позволяет вычислять на этапе компиляции, что важно для статических констант.

## **Метод `main_write_char()`**

```rust
fn main_write_char(&mut self, byte: u8) {
    self.render_vga_char(byte); // Отображение символа
    self.check_buffer();       // Проверка границ
}
```

**Поток выполнения:**
1. `check_buffer()` — проверяет, не нужно ли перейти на новую строку или прокрутить экран
2. `render_vga_char()` — отображает символ в буфере и видеопамяти
3. `col += 1` — перемещает курсор на одну позицию вправо

## **Метод `render_vga_char()`**

```rust
fn render_vga_char(&mut self, byte: u8) {
let idx = self.row * 80 + self.col;
let base_addr = 0xb8000 as *mut u8;

self.screen_text[idx] = byte;
self.screen_color[idx] = self.write_color;

	unsafe {
		let addr = base_addr.add(idx * 2);
		*addr = self.screen_text[idx];
		*addr.offset(1) = self.screen_color[idx];
	}
self.col += 1;

}
```

**Математика индексации:**
- Экран: 25 строк × 80 колонок = 2000 символов
- `row * 80 + col` преобразует координаты (строка, колонка) в линейный индекс
- Например: строка 2, колонка 10 → `2*80 + 10 = 170`

**Структура видеопамяти:**
```
Адрес: 0xb8000 + (индекс * 2)
       ↓
[байт_символа][байт_цвета][байт_символа][байт_цвета]...
```

## **Метод `full_render_buffer()`**

```rust
fn full_render_buffer(&mut self) {
    let base_addr = 0xb8000 as *mut u8;
    unsafe {
        for idx in 0..self.screen_text.len() {
            let addr = base_addr.add(idx * 2);
            *addr = self.screen_text[idx];
            *addr.offset(1) = self.screen_color[idx];
        }
    }
}
```

**Назначение:** Полное обновление видеопамяти из внутренних буферов. Используется после операций, затрагивающих большие области экрана (прокрутка, очистка).

**Эффективность:** Обновление всех 2000 символов за один проход вместо посимвольных операций.

## **Метод `check_buffer()`**

```rust
fn check_buffer(&mut self) {
    if self.col >= 80 {
        self.next_line();  // Перенос строки
    }
    if self.row == 24 {
        self.scroll_up();  // Прокрутка экрана
    }
}
```

**Логика проверки:**
1. Если курсор в колонке 80 или больше (выход за правую границу) → переход на новую строку
2. Если курсор в строке 24 (последняя строка) → прокрутка экрана вверх

## **Метод `scroll_up()` — самая сложная часть**

```rust
fn scroll_up(&mut self) {
    // Сдвиг строк вверх
    for row in 1..25 {
        for col in 0..80 {
            let src_idx = row * 80 + col;
            let dst_idx = (row - 1) * 80 + col;
            self.screen_text[dst_idx] = self.screen_text[src_idx];
            self.screen_color[dst_idx] = self.screen_color[src_idx];
        }
    }
    
    // Очистка последней строки
    let last_row = 24 * 80;
    for i in 0..80 {
        self.screen_text[last_row + i] = b' ';
        self.screen_color[last_row + i] = Color::BLACK;
    }
    
    // Обновление видеопамяти
    self.full_render_buffer();
    // Позиция курсора
    self.row = 24;
    self.col = 0;
}
```
![[scroll_up.mp4]]


## **Метод `clear_buffer()`**

```rust
pub fn clear_buffer(&mut self) {
    self.screen_text = [0; 25 * 80];
    self.screen_color = [Color::BLACK; 25 * 80];
    self.col = 0;
    self.row = 0;
    self.full_render_buffer();
}
```

**Особенности:**
- `pub` — публичный метод, может вызываться извне
- Использует массивные присваивания для быстрой очистки
- Сбрасывает курсор в (0, 0)
- Обновляет видеопамять одним вызовом `full_render_buffer()`
![[clear_buffer.mp4]]
## **Метод `first_line()`**

```rust
fn first_line(&mut self) {
    for i in 0..80 {
        self.screen_text[i] = b' ';
        self.screen_color[i] = Color::BLACK;
    }
    self.row = 0;
    self.col = 0;
    self.full_render_buffer();
}
```

![[first_line.mp4]]
**Специфика:** Очищает только первую строку и сбрасывает курсор. Нестандартное поведение, но может быть полезно для заголовков или статусных строк.


## **Метод `next_line()`**

```rust
fn next_line(&mut self) {
    if self.row < 24 {
        self.row += 1;
        self.col = 0;
    }
    // Если уже на последней строке, прокрутка выполнится через check_buffer()
}
```

**Простота и эффективность:** Только изменение координат курсора, без операций с памятью.

## **Метод `tab()`**

```rust
fn tab(&mut self) {
    self.col += 4;
}
```

**Упрощённая реализация:**
- Добавляет 4 к текущей колонке
- **Проблема:** Не проверяет выход за границы строки
- **Проблема:** Не обрабатывает перенос при достижении конца строки
# **Файл [main.rs] для текущего этапа Runix**

## **Структура проекта и инициализация**
```rust
// src/main.rs
#![no_std]
#![no_main]

pub mod drivers;
pub mod set_macros;

extern crate alloc;

#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();

use linked_list_allocator::LockedHeap;
use core::panic::PanicInfo;

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    println!("Runix Kernel v0.1.0");
    let mut couter = 0;
    loop {
        println!("\nTick: {}", couter);
        couter += 1;
        for _ in 0..10000 {
            core::hint::spin_loop();
        }
    }
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

## Полный код драйвера VGA

```rust
/// VGA println implementation for XD8000
use crate::drivers::vga::xd8000::color::Color;
use spin::Mutex;
use core::fmt::Write;

struct VgaState {
    screen_text: [u8; 25*80],
    screen_color: [u8; 25*80],
    row: usize, col: usize,
    write_color: u8,
}

static STATE: Mutex<VgaState> = Mutex::new(VgaState::new());

fn vga_print(args: core::fmt::Arguments, color: u8) {
    let mut printer = VGAPrinter;
    STATE.lock().write_color = color;
    core::fmt::Write::write_fmt(&mut printer, args).unwrap();
}

pub fn println(args: core::fmt::Arguments) { vga_print(args, Color::WHITE); }
pub fn println_warn(args: core::fmt::Arguments) { vga_print(args, Color::warning()); }
pub fn println_error(args: core::fmt::Arguments) { vga_print(args, Color::error()); }

struct VGAPrinter;
impl Write for VGAPrinter {
    fn write_str(&mut self, text: &str) -> core::fmt::Result {
        let mut state = STATE.lock();
        for byte in text.bytes() {
            match byte {
                b'\n' => state.next_line(),
                b'\r' => state.first_line(),
                b'\t' => state.tab(),
                32..=126 => state.main_write_char(byte),
                _ => {}
            }
        }
        Ok(())
    }
}

impl VgaState {
    const fn new() -> Self {
        Self { screen_text: [0; 25*80], screen_color: [0; 25*80],
               row: 0, col: 0, write_color: Color::WHITE }
    }
    
    fn main_write_char(&mut self, byte: u8) {
        self.render_vga_char(byte);
        self.check_buffer();
    }
    
    fn render_vga_char(&mut self, byte: u8) {
        let idx = self.row * 80 + self.col;
        let base = 0xb8000 as *mut u8;
        self.screen_text[idx] = byte;
        self.screen_color[idx] = self.write_color;
        unsafe {
            let addr = base.add(idx * 2);
            *addr = byte;
            *addr.offset(1) = self.write_color;
        }
        self.col += 1;
    }
    
    fn full_render_buffer(&mut self) {
        let base = 0xb8000 as *mut u8;
        unsafe {
            for idx in 0..self.screen_text.len() {
                let addr = base.add(idx * 2);
                *addr = self.screen_text[idx];
                *addr.offset(1) = self.screen_color[idx];
            }
        }
    }
    
    fn check_buffer(&mut self) {
        if self.col >= 80 { self.next_line(); }
        if self.row == 24 && self.col >= 80 { self.scroll_up(); }
    }
    
    fn scroll_up(&mut self) {
        for row in 1..25 {
            for col in 0..80 {
                let src = row * 80 + col;
                let dst = (row - 1) * 80 + col;
                self.screen_text[dst] = self.screen_text[src];
                self.screen_color[dst] = self.screen_color[src];
            }
        }
        let last = 24 * 80;
        for i in 0..80 {
            self.screen_text[last + i] = b' ';
            self.screen_color[last + i] = Color::BLACK;
        }
        self.full_render_buffer();
        self.row = 24;
        self.col = 0;
    }
    
    pub fn clear_buffer(&mut self) {
        self.screen_text = [0; 25*80];
        self.screen_color = [Color::BLACK; 25*80];
        self.col = 0; self.row = 0;
        self.full_render_buffer();
    }
    
    fn first_line(&mut self) {
        for i in 0..80 {
            self.screen_text[i] = b' ';
            self.screen_color[i] = Color::BLACK;
        }
        self.row = 0; self.col = 0;
        self.full_render_buffer();
    }
    
    fn next_line(&mut self) {
        if self.row < 24 {
            self.row += 1;
            self.col = 0;
        } else {
            self.scroll_up();
        }
    }
    
    fn tab(&mut self) { self.col += 4; }
}
```


## **Потенциальные проблемы в реализации**

### **1. Гонка цвета**
```rust
// В vga_print():
STATE.lock().write_color = color;  // Мьютекс освобождается!
// Потом вызывается write_str(), который берёт новый lock
// Другой поток может изменить цвет между этими вызовами
```

### **2. Неатомарность операций**
Прокрутка экрана (`scroll_up()`) состоит из нескольких шагов. Если прерывание произойдёт в середине процесса, на экране может оказаться "полупрокрученное" состояние.

### **3. Отсутствие проверок в `tab()`**
Табуляция может вывести курсор за границы строки.

### **4. Эффективность `scroll_up()`**
Двойной вложенный цикл для 24×80 = 1920 операций копирования может быть оптимизирован через копирование блоков памяти.
## **Заключение**

# **Заключение по реализации VGA драйвера в Runix**

Реализация драйвера VGA для текстового режима представляет собой фундаментальный этап в развитии операционной системы Runix. Эта работа демонстрирует ключевые принципы системного программирования на Rust и закладывает основу для всех последующих компонентов системы.



## **Достигнутые результаты:**

### **1. Безопасные абстракции поверх аппаратуры**

Мы успешно создали драйвер, который инкапсулирует сложность работы с VGA контроллером, предоставляя простой и безопасный интерфейс для вывода текста. Использование структуры `VgaState` с защитой через `Mutex` обеспечивает корректную работу в потенциально многозадачной среде.

### **2. Эффективная архитектура вывода**

Реализация двойной буферизации с полным рендерингом экрана устраняет мерцание и обеспечивает плавный вывод текста. Методы обработки управляющих символов (`\n`, `\r`, `\t`) создают основу для полноценного терминального интерфейса.

### **3. Интеграция с экосистемой Rust**

Путем реализации трейта `Write` и создания макросов `println!`, `println_warn!`, `println_error!` мы обеспечили идиоматичный интерфейс, знакомый разработчикам Rust, что снижает когнитивную нагрузку и упрощает отладку.

### **4. Масштабируемая архитектура**

Структура кода позволяет легко добавлять новые функции:

- Поддержку дополнительных управляющих символов
    
- Расширенную цветовую палитру
    
- Прокрутку с историей (scrollback buffer)
    
- Графические режимы VGA
    

## **Образовательная ценность:**

Создание этого драйвера наглядно показало:

- Как работать с аппаратными регистрами и памятью в Rust
    
- Важность синхронизации в системном программировании
    
- Принципы создания безопасных абстракций
    
- Подход к обработке edge cases и граничных условий
[[Планировщик Вступление]]