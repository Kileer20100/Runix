## **Введение: От теории к практике**

В предыдущих материалах мы обсуждали философию проекта Runix и создали минимальный независимый исполняемый файл. Теперь пришло время превратить эту основу в настоящее загружаемое ядро, способное взаимодействовать с пользователем. Наша цель — создать систему, которая при загрузке выводит на экран классическое "Hello World!".

Этот этап — критически важный мост между абстрактной концепцией и работающей системой. Мы переходим от компиляции кода для "голого железа" к созданию образа, который может быть загружен реальным компьютером.

## **Понимание процесса загрузки: Что происходит при включении питания**

Прежде чем погрузиться в код, давайте разберёмся, как компьютер загружает операционную систему. Этот процесс напоминает эстафету, где управление передаётся от одного компонента к другому:

### **Фазы загрузки x86_64**

1. **Прошивка (BIOS/UEFI)** — резидентный код в ПЗУ материнской платы
    
    - Выполняет самодиагностику (POST)
        
    - Инициализирует базовое оборудование
        
    - Ищет загрузочное устройство
        
2. **Загрузчик** — небольшая программа в начале диска
    
    - Загружает ядро в память
        
    - Переводит процессор в 64-битный режим
        
    - Передаёт управление ядру
        
3. **Ядро** — наша операционная система
    
    - Инициализирует подсистемы
        
    - Запускает основные службы
        
    - Передаёт управление пользовательским программам
        

### **Выбор стратегии загрузки**

Для Runix мы выбрали простейший путь — использование BIOS. Причины:

- **Универсальность**: Поддерживается на любом x86-совместимом оборудовании
    
- **Простота**: Меньше начальных сложностей для образовательного проекта
    
- **Прозрачность**: Позволяет лучше понять фундаментальные механизмы
    

_Примечание: Поддержка UEFI планируется на более поздних этапах развития Runix.

## **Настройка инструментария: Подготовка рабочего окружения**

### **Установка необходимых компонентов Rust**
```
# Устанавливаем nightly-версию Rust
rustup install nightly

# Устанавливаем инструменты для работы с bare-metal
rustup component add rust-src --toolchain nightly
rustup component add llvm-tools-preview
```

### **Создание целевой платформы для bare-metal**

Поскольку стандартные цели Rust предназначены для работы под управлением операционной системы, нам необходимо определить собственную. Создаём файл `x86_64-runix.json`:

```rust
{
  "llvm-target": "x86_64-unknown-none",
  "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128",
  "arch": "x86_64",
  "target-endian": "little",
  "target-pointer-width": 64,
  "target-c-int-width": 32,
  "os": "none",
  "executables": true,
  "linker-flavor": "ld.lld",
  "linker": "rust-lld",
  "panic-strategy": "abort",
  "disable-redzone": true,
  "features": "-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2",
  "stack-protector": false
}
```
**Ключевые особенности нашей конфигурации:**

- `"os": "none"` — указывает на отсутствие операционной системы
    
- `linker: "rust-lld"` — используем кросс-платформенный компоновщик от LLVM
    
- `panic-strategy: "abort"` — отключаем раскрутку стека при панике
    
- `disable-redzone: true` — необходимо для корректной обработки прерываний
    
- Отключение SIMD-инструкций — упрощает сохранение состояния процессора

### **Настройка Cargo для системной разработки**

Создаём `.cargo/config.toml`:

```rust
[unstable]
build-std = ["core", "compiler_builtins"]
build-std-features = ["compiler-builtins-mem"]

[build]
target = "x86_64-runix.json"

[target.'cfg(target_os = "none")']
runner = "bootimage runner"
```
Эта конфигурация позволяет:

- Перекомпилировать `core` библиотеку для нашей цели
    
- Включить базовые функции работы с памятью
    
- Установить цель по умолчанию
    
- Настроить автоматический запуск в QEMU через `cargo run`

## **Минимальное рабочее ядро**

### **Структура кода**

```rust

// src/main.rs

#![no_std]    // Не используем стандартную библиотеку
#![no_main]   // Определяем свою точку входа

use core::panic::PanicInfo;

/// Обработчик паники для bare-metal окружения
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    // В реальном ядре здесь будет логирование и безопасное завершение
    loop {}
}

/// Точка входа, вызываемая загрузчиком
#[no_mangle]  // Сохраняем имя для компоновщика
pub extern "C" fn _start() -> ! {
    // Адрес буфера VGA в памяти
    let vga_buffer = 0xb8000 as *mut u8;
    
    // Сообщение для вывода
    let hello = b"Runix Kernel v0.1.0";
    
    // Выводим каждый символ в буфер VGA
    for (i, &byte) in hello.iter().enumerate() {
        unsafe {
            // Символ
            *vga_buffer.offset(i as isize * 2) = byte;
            // Атрибут цвета (светло-голубой на чёрном)
            *vga_buffer.offset(i as isize * 2 + 1) = 0x0B;
        }
    }
    
    // Бесконечный цикл — ядро не должно завершаться
    loop {}
}
```
![[Minimum_working_core.png]]
### **Объяснение ключевых моментов**

1. **Буфер VGA** — специальная область памяти по адресу `0xb8000`, которая напрямую отображается на экран в текстовом режиме.
    
2. **Структура ячейки** — каждый символ занимает 2 байта:
    
    - Байт 0: Код символа ASCII
        
    - Байт 1: Атрибуты (цвет фона и текста)
        
3. **Блоки `unsafe`** — необходимы для работы с сырыми указателями. В дальнейшем мы инкапсулируем эту логику в безопасные абстракции.

## **Сборка и запуск**

### **Установка дополнительных инструментов**

```
# Утилита для создания загрузочных образов
cargo install bootimage
```

### **Конфигурация проекта**

```rust
# Cargo.toml
[package]
name = "runix-kernel"
version = "0.1.0"
edition = "2021"

[dependencies]
bootloader = "0.9"

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

### **Команды для сборки и запуска**

# Стандартная сборка
```
cargo build
```

# Создание загрузочного образа
```
cargo bootimage
```

# Сборка и запуск в QEMU
```
cargo run
```

# Ручной запуск в QEMU
```
qemu-system-x86_64 -drive format=raw,file=target/x86_64-runix/debug/bootimage-runix-kernel.bin
```

## **Что мы достигли: Анализ результата**
### **Технические достижения**

1. **Рабочий загрузочный образ** — файл, который можно записать на USB-накопитель и загрузить на реальном оборудовании.
    
2. **Контроль над оборудованием** — прямое управление видеобуфером без посредников.
    
3. **Минимальные зависимости** — только компилятор Rust и несколько инструментов.
    

### **Образовательная ценность**

1. **Понимание загрузки** — от включения питания до выполнения первого инструкции ядра.
    
2. **Работа с памятью** — прямое отображение аппаратных ресурсов.
    
3. **Безопасность Rust в системном программировании** — даже в таком низкоуровневом коде Rust обеспечивает гарантии.
    

### **Ограничения текущей реализации**

1. **Только BIOS** — не поддерживается современный UEFI.
    
2. **Примитивный вывод** — прямое манипулирование видеобуфером.
    
3. **Нет обработки ошибок** — паника приводит к бесконечному циклу.
    
4. **Минимальная функциональность** — только вывод текста.
    

## **Архитектурные решения и их обоснование**

### **Почему именно такой подход?**

1. **Простота перед функциональностью** — на этапе обучения важно понимать каждый шаг.
    
2. **Минимализм** — каждая строка кода должна быть понятна и обоснована.
    
3. **Постепенное усложнение** — от "Hello World" к полноценной ОС.
    

### **Альтернативы, которые мы не выбрали**

1. **GRUB/Multiboot** — хотя это стандарт в мире Linux, он добавляет сложность и скрывает важные детали загрузки.
    
2. **Собственный загрузчик** — хотя это дало бы полный контроль, это отдельный большой проект.
    
3. **UEFI с самого начала** — современнее, но сложнее для понимания основ.
    

## **Следующие шаги для Runix**

### **Ближайшие цели**

1. **Безопасная абстракция VGA** — инкапсулировать работу с видеобуфером в типобезопасный интерфейс.
    
2. **Макрос `println!`** — удобный вывод для отладки.
    
3. **Обработка прерываний** — основа для работы с клавиатурой, таймером и другими устройствами.
    
4. **Управление памятью** — аллокатор для ядра и подготовка к виртуальной памяти.
    

### **Долгосрочная перспектива**

Каждый компонент, который мы добавим, будет строиться на этом фундаменте:

- Драйверы устройств
    
- Файловая система
    
- Планировщик задач
    
- Пользовательское пространство
    

## **Заключение: От концепции к реальности**

Создание этого минимального ядра — важнейший психологический и технический рубеж. Мы перешли от абстрактных рассуждений об архитектуре ОС к коду, который можно запустить, увидеть и модифицировать.

Этот "Hello World" — не просто демонстрация работы. Это:

- **Доказательство концепции** — Rust действительно подходит для системного программирования
    
- **Фундамент для роста** — каждая будущая функция будет добавляться к этой основе
    
- **Инструмент обучения** — работающая система, которую можно исследовать и изменять
    

В следующих материалах мы превратим эту простую демонстрацию в основу для настоящей операционной системы, добавляя слой за слоем, всегда понимая, как каждый компонент взаимодействует с целым.

[[Creating_first_Runix_VGA_text_output_driver]]

**Ключевые выводы:**

- Минимальное ядро — это достижимая цель даже для начинающих
    
- Rust предоставляет необходимые инструменты без потери контроля
    
- Понимание процесса загрузки критически важно для разработки ОС
    
- Каждый следующий шаг строится на фундаменте предыдущих