# Ассемблер и Rust: Связь высокого и низкого уровня

## 1. Зачем связывать Rust с ассемблером?

Rust — язык высокого уровня, удобный и безопасный. Но иногда нужно:

- Максимальная производительность
- Прямое управление железом
- Оптимизация критичных участков
- Работа с кодом, которого нет в стандартной библиотеке

Ассемблер даёт абсолютный контроль над процессором, а Rust позволяет безопасно управлять сложными структурами и памятью. Вместе они дают мощь и гибкость.

## 2. Подготовка ассемблера для вызова из Rust

### Шаг 1: Пишем функцию на NASM

Пример функции сложения двух чисел:

```assembly
; sum.asm
global add_numbers
section .text
add_numbers:
    mov rax, rdi    ; первый аргумент → RAX
    add rax, rsi    ; прибавляем второй аргумент
    ret
```

**Важно:**

- `global add_numbers` — делает функцию видимой для компоновщика
- Используем System V AMD64 ABI, чтобы Rust знал, куда передавать аргументы

### Шаг 2: Компиляция в объектный файл

```
nasm -f elf64 sum.asm -o sum.o
```

- `-f elf64` → объектный файл для x86_64 Linux
- Можно затем собрать статическую библиотеку:

```
ar rcs libasm.a sum.o
```

## 3. Вызов ассемблера из Rust

### 3.1 Объявление функции в Rust

```rust
extern "C" {
    fn add_numbers(a: u64, b: u64) -> u64;
}

fn main() {
    let a = 10;
    let b = 20;

    let sum: u64;

    unsafe {
        sum = add_numbers(a, b);
    }

    println!("Сумма: {}", sum);
}
```

**Объяснение:**

- `extern "C"` → Rust использует стандартные правила вызова функций (ABI)
- `unsafe` → вызов внешнего кода может быть небезопасным
- Результат возвращается через rax (стандарт для 64-битных целых чисел)

### 3.2 Связка через Cargo

В build.rs можно автоматически копировать библиотеку:

```rust
use std::env;
use std::path::PathBuf;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    std::fs::copy("libasm.a", out_dir.join("libasm.a")).unwrap();
    println!("cargo:rustc-link-search=native={}", out_dir.display());
    println!("cargo:rustc-link-lib=static=asm");
}
```

- `cargo build` автоматически подхватит библиотеку
- Rust сможет вызывать ассемблерный код напрямую

## 4. Пример: Сумма массива

### Ассемблерная функция:

```assembly
global sum_array
section .text
sum_array:
    xor rax, rax       ; сумма = 0
.loop:
    test rsi, rsi
    jz .done
    add rax, [rdi + rcx*8]
    inc rcx
    dec rsi
    jnz .loop
.done:
    ret
```

### Rust:

```rust
extern "C" {
    fn sum_array(ptr: *const u64, len: u64) -> u64;
}

fn main() {
    let arr = [1, 2, 3, 4, 5];

    let sum: u64;
    unsafe {
        sum = sum_array(arr.as_ptr(), arr.len() as u64);
    }

    println!("Сумма массива: {}", sum);
}
```

## 5. Практические советы

- Всегда проверяйте ABI — регистры и порядок аргументов должны совпадать
- Используйте `extern "C"` для совместимости
- Используйте `unsafe` только для вызова ассемблера
- Тестируйте на небольших функциях — сложный ассемблерный код трудно отлаживать

## 6. Что дальше?

- Вы освоили простые функции на ассемблере и вызов из Rust
- Можно создавать оптимизированные ядра, драйверы, обработчики прерываний
- Следующий шаг — встраивание ассемблера в системное программирование и работу с портами/устройствами
