# **Создание первого кода на языке ASM**

## **Введение: Необходимость ассемблера в ядре**

Мы уже создали первый драйвер на Rust. Теперь нужно подключить ASM к нашему Rust-коду. Зачем это нужно? Потому что невозможно создать планировщик для ядра без прямого обращения к ассемблеру. Мы обсудим это подробнее в будущем.

## **Интеграция ассемблера в Rust**

### **Rust-код с вызовом ассемблерной функции**

```rust
// src/cpu/cpu_info.rs

use crate::println;

// Объявляем внешнюю ассемблерную функцию
unsafe extern "C" {
    fn add(a: i64, b: i64) -> i64;
}

pub fn cpu_info() {
    println!("Add: {}", unsafe {
        add(1, 2)
    });
}
```

**Что здесь происходит:**
1. `extern "C"` — указывает, что функция использует соглашение о вызовах C
2. `unsafe` — необходим, так как вызываем код, который Rust не может проверить
3. `add(1, 2)` — вызываем ассемблерную функцию сложения

### **Ассемблерная реализация**

```nasm
; src/cpu/cpu_info.asm
bits 64          ; 64-битный режим процессора
global add       ; Экспортируем функцию для линковки

section .text    ; Исполняемый сегмент кода
add:
    mov rax, rdi ; Первый аргумент (a) из RDI в RAX
    add rax, rsi ; Прибавляем второй аргумент (b) из RSI
    ret          ; Возвращаем результат в RAX
```

**Объяснение:**
1. `bits 64` — генерируем 64-битный код
2. `global add` — делаем функцию видимой для линковщика
3. `add:` — метка функции
4. Согласно System V AMD64 ABI:
   - Первый аргумент передаётся в RDI
   - Второй аргумент передаётся в RSI
   - Результат возвращается в RAX

## **Сборка проекта**

### **Команды сборки вручную**

```bash
# Компилируем ассемблерный код
nasm -f elf64 src/cpu/cpu_info.asm -o cpu_info.o

# Создаём статическую библиотеку
ar rcs libasm.a cpu_info.o
```

### **Автоматизация сборки через build.rs**

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Копируем собранную библиотеку (предполагаем, что она уже собрана)
    std::fs::copy("libasm.a", out_dir.join("libasm.a")).unwrap();

    // Указываем линковщику где искать библиотеку
    println!("cargo:rustc-link-search=native={}", out_dir.display());
    println!("cargo:rustc-link-lib=static=asm");
}
```

## **Как это работает вместе**

### **Процесс сборки:**
1. NASM компилирует `cpu_info.asm` в объектный файл `cpu_info.o`
2. AR создаёт статическую библиотеку `libasm.a`
3. build.rs копирует библиотеку в выходную директорию Cargo
4. Rust линковщик подключает библиотеку к нашему ядру
5. Rust код вызывает ассемблерную функцию через FFI

### **Результат выполнения:**
При вызове `cpu_info()` будет выведено:
![core](media/add_asm.png)
## **Следующие шаги**

Это базовая интеграция ассемблера. В будущем мы:
1. Добавим автоматическую сборку ассемблерного кода в build.rs
2. Создадим реальные функции работы с процессором
3. Реализуем переключение контекста для планировщика
4. Добавим обработку прерываний

Сейчас мы доказали, что можем вызывать ассемблерный код из Rust, что открывает путь к созданию полноценного планировщика задач.