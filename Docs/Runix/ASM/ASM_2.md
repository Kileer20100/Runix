# Ключевые инструкции x86_64 для системного программирования

## 1. Перемещение данных

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `mov` | Копирует данные из источника в назначение | `mov rax, rbx` – копирует значение RBX в RAX |
| `lea` | Загружает адрес в регистр, не данные | `lea rax, [rdi+rcx*8]` – адрес элемента массива |
| `movzx` | Расширяет маленькое значение в больший регистр с заполнением нулями | `movzx rax, byte [rdi]` |
| `movsx` | Расширяет маленькое значение с сохранением знака | `movsx rax, byte [rdi]` |
| `push` | Кладёт значение на вершину стека | `push rax` |
| `pop` | Снимает значение со стека | `pop rbx` |

## 2. Арифметика и логика

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `add` | Сложение | `add rax, rbx` |
| `sub` | Вычитание | `sub rax, 5` |
| `inc` | Увеличение на 1 | `inc rcx` |
| `dec` | Уменьшение на 1 | `dec rcx` |
| `mul` | Умножение (без знака) | `mul rbx` – RAX = RAX * RBX |
| `imul` | Умножение со знаком | `imul rbx` |
| `div` | Деление (без знака) | `div rbx` – RAX/RDX делится на RBX |
| `idiv` | Деление со знаком | `idiv rbx` |
| `xor` | Логическое XOR | `xor rax, rax` – часто для обнуления регистра |
| `and` | Логическое AND | `and rax, 0xFF` |
| `or` | Логическое OR | `or rax, rbx` |
| `not` | Побитовое отрицание | `not rax` |
| `shl` | Сдвиг влево | `shl rax, 1` – умножение на 2 |
| `shr` | Сдвиг вправо | `shr rax, 1` – деление на 2 без знака |
| `sar` | Арифметический сдвиг вправо (со знаком) | `sar rax, 1` |

## 3. Сравнения и условные переходы

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `cmp` | Сравнение двух значений, результат в флагах | `cmp rax, rbx` |
| `test` | Логическое И для установки флагов | `test rax, rax` – проверка на ноль |
| `je`/`jz` | Перейти, если равны / ноль | `je .label` |
| `jne`/`jnz` | Перейти, если не равны / не ноль | `jne .label` |
| `jg`/`jnle` | Перейти если больше (со знаком) | `jg .label` |
| `jl`/`jnge` | Перейти если меньше (со знаком) | `jl .label` |
| `jge`/`jnl` | Перейти если больше или равно | `jge .label` |
| `jle`/`jng` | Перейти если меньше или равно | `jle .label` |

## 4. Циклы и работа с RCX

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `loop` | Уменьшает RCX и прыгает, если не ноль | `loop .loop_start` |
| `jecxz` | Прыжок, если RCX = 0 | `jecxz .end_loop` |

## 5. Вызовы функций и возврат

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `call` | Вызов функции | `call my_function` |
| `ret` | Возврат из функции | `ret` |
| `enter` | Установка нового кадра стека | `enter 16,0` |
| `leave` | Снятие кадра стека | `leave` |

## 6. Стек и регистры RBP/RSP

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `push` | Сохраняет регистр на стек | `push rbx` |
| `pop` | Восстанавливает регистр из стека | `pop rbx` |
| `mov rbp, rsp` | Создаёт базовую точку для локальных переменных | |

### Пример сохранения контекста функции:

```assembly
push rbp
mov rbp, rsp
push rbx
; ... тело функции ...
pop rbx
pop rbp
ret
```

## 7. Работа с памятью

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `mov rax, [rdi]` | Чтение 8 байт из памяти | `[rdi]` — косвенная адресация |
| `mov [rdi], rax` | Запись 8 байт в память | |
| `mov rax, [rdi + 8]` | Сдвиг на 1 элемент (64-бит) | |
| `mov rax, [rdi + rcx*8]` | Индексная адресация массива | |

## 8. Системные инструкции и I/O

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `in al, dx` | Чтение байта с порта DX в AL | `in al, 0x60` |
| `out dx, al` | Запись байта из AL в порт DX | `out 0x60, al` |
| `hlt` | Остановка процессора до следующего прерывания | `hlt` |
| `cli` | Запрет прерываний | `cli` |
| `sti` | Разрешение прерываний | `sti` |
| `syscall` | Вызов системного вызова (Linux) | `mov rax,60 ; xor rdi,rdi ; syscall` |

## 9. Работа со строковыми данными

| Инструкция | Описание | Пример |
|------------|----------|---------|
| `movsb` | Копирует байт из [RSI] в [RDI], увеличивает RSI и RDI | `rep movsb` — копирует строку |
| `movsw` | Копирует слово (2 байта) | `rep movsw` |
| `movsd` | Копирует двойное слово (4 байта) | `rep movsd` — эффективное копирование памяти |
| `movsq` | Копирует учетверённое слово (8 байт) | `rep movsq` |
| `cmpsb` | Сравнивает байты [RSI] и [RDI] | `repe cmpsb` — сравнение строк |
| `stosb` | Сохраняет AL в [RDI], увеличивает RDI | `rep stosb` — заполнение памяти значением |
| `lodsb` | Загружает байт из [RSI] в AL, увеличивает RSI | `lodsb` |
| `scasb` | Сравнивает AL с байтом [RDI] | `repne scasb` — поиск символа в строке |

### Пример использования строковых инструкций:

```assembly
; Копирование блока памяти (16 байт)
mov rsi, source    ; Источник
mov rdi, dest      ; Назначение
mov rcx, 2         ; Количество 8-байтных блоков (16/8 = 2)
rep movsq          ; Копируем 2 раза по 8 байт

; Заполнение буфера нулями
mov rdi, buffer
mov rcx, 1024      ; Размер в байтах
mov al, 0
rep stosb          ; Заполняем 1024 байта нулями
```

## 10. Привилегированные инструкции для ядра ОС

| Инструкция | Описание | Когда используется |
|------------|----------|-------------------|
| `lgdt` | Загружает Global Descriptor Table | При инициализации ядра |
| `lidt` | Загружает Interrupt Descriptor Table | Настройка обработчиков прерываний |
| `ltr` | Загружает Task Register | При переключении задач |
| `lcr0`, `lcr3`, `lcr4` | Загрузка в контрольные регистры | Настройка режимов процессора |
| `mov crN, reg` | Запись в контрольный регистр | |
| `mov reg, crN` | Чтение из контрольного регистра | |
| `invd` | Инвалидация кэша (без записи) | При изменении страничных таблиц |
| `wbinvd` | Инвалидация кэша (с записью) | |
| `cpuid` | Получение информации о процессоре | Определение возможностей CPU |
| `rdtsc` | Чтение счётчика тактов | Для замеров производительности |
| `rdpmc` | Чтение счётчиков производительности | Профилирование |
| `wrmsr` | Запись в Model-Specific Register | Настройка процессора |
| `rdmsr` | Чтение из Model-Specific Register | |

### Пример работы с MSR (Model-Specific Registers):

```assembly
; Включение SSE (Streaming SIMD Extensions)
mov ecx, 0xC0010015 ; MSR для включения SSE
rdmsr               ; Читаем текущее значение
or eax, 3           ; Устанавливаем биты SSE
wrmsr               ; Записываем обратно

; Получение информации о процессоре
mov eax, 1          ; Функция 1 CPUID
cpuid
test edx, 1 << 25   ; Проверяем бит SSE
jnz sse_available
```

## 11. SIMD инструкции (MMX/SSE/AVX)

| Категория | Инструкция | Описание | Пример |
|-----------|------------|----------|---------|
| MMX | `paddb`, `paddw`, `paddd`, `paddq` | Параллельное сложение | `paddd mm0, mm1` |
| | `psubb`, `psubw`, `psubd`, `psubq` | Параллельное вычитание | |
| SSE | `addps`, `addss` | Сложение float (packed/scalar) | `addps xmm0, xmm1` |
| | `subps`, `subss` | Вычитание float | |
| | `mulps`, `mulss` | Умножение float | |
| | `divps`, `divss` | Деление float | |
| | `sqrtps`, `sqrtss` | Квадратный корень | |
| | `movaps`, `movups` | Перемещение выровненное/невыровненное | |
| AVX | `vaddps`, `vsubps` | 256-битные векторные операции | `vaddps ymm0, ymm1, ymm2` |
| | `vmulps`, `vdivps` | | |
| | `vsqrtps` | | |

### Пример SIMD вычислений:

```assembly
; Умножение 4 чисел с плавающей точкой одновременно
movaps xmm0, [array1]   ; Загружаем 4 float (16 байт)
movaps xmm1, [array2]   ; Ещё 4 float
mulps xmm0, xmm1        ; Перемножаем все 4 пары одновременно
movaps [result], xmm0   ; Сохраняем 4 результата
```

## 12. Атомарные операции (для многопоточности)

| Инструкция | Описание | Использование |
|------------|----------|--------------|
| `lock xadd` | Атомарное сложение с возвратом старого значения | Счётчики, спинлоки |
| `lock cmpxchg` | Сравнить и обменять (CAS) | Основная примитивная операция |
| `lock inc` | Атомарное увеличение | |
| `lock dec` | Атомарное уменьшение | |
| `lock or` | Атомарное ИЛИ | |
| `lock and` | Атомарное И | |
| `mfence` | Барьер памяти полного упорядочения | |
| `sfence` | Барьер для операций записи | |
| `lfence` | Барьер для операций чтения | |

### Пример атомарных операций:

```assembly
; Атомарный инкремент счётчика
lock inc qword [counter]

; Сравнение с обменом (Compare-And-Swap)
; if (*ptr == old) { *ptr = new; return true; } else { return false; }
mov rax, old_value
mov rdx, new_value
lock cmpxchg [ptr], rdx
; ZF=1 если обмен произошёл
```

## 13. Инструкции для виртуальной памяти

| Инструкция | Описание | Использование в ядре |
|------------|----------|---------------------|
| `invlpg` | Инвалидация TLB для одной страницы | При изменении отображения страницы |
| `invpcid` | Инвалидация TLB с указанием PCID | В современных процессорах |
| `clflush` | Сброс кэш-линии | |
| `clflushopt` | Оптимизированный сброс кэш-линии | |
| `prefetch` | Предварительная загрузка в кэш | Оптимизация доступа к памяти |

## 14. Отладочные инструкции

| Инструкция | Описание | Использование |
|------------|----------|--------------|
| `int3` | Программное прерывание для отладчика | Точки останова |
| `ud2` | Неопределённая инструкция (вызывает исключение) | Тестирование обработчиков исключений |
| `xchg bx, bx` | Точка останова для Bochs эмулятора | |
| `pause` | Улучшение производительности спинлока | В busy-wait циклах |

## 15. 16-битные и 32-битные режимы

| Инструкция | Описание | Использование при загрузке |
|------------|----------|---------------------------|
| `aam`, `aad` | ASCII-коррекция для BCD | Устаревшие, для обратной совместимости |
| `daa`, `das` | Десятичная коррекция | |
| `into` | Прерывание при переполнении | |
| `bound` | Проверка границ массива | |

## 16. Специальные регистры и доступ к ним

| Контрольный регистр | Описание | Биты |
|---------------------|----------|------|
| CR0 | Режим процессора, защита памяти, кэширование | PE (Protected Mode), PG (Paging) |
| CR2 | Линейный адрес, вызвавший Page Fault | Для отладки ошибок страниц |
| CR3 | Указатель на таблицу страниц (PML4) | Физический адрес корня страничной таблицы |
| CR4 | Расширенные функции | PAE, PSE, OSFXSR (SSE), OSXMMEXCPT |
| EFER (MSR 0xC0000080) | Extended Feature Enable Register | LME (Long Mode Enable), NXE (No-Execute Enable) |

### Пример настройки страничной таблицы:

```assembly
; Включение страничной организации памяти
mov rax, page_table_base
mov cr3, rax               ; Устанавливаем корень страничной таблицы

mov rax, cr0
or rax, 0x80000000         ; Устанавливаем бит PG (страничная организация)
mov cr0, rax
```

## 17. Инструкции для энергосбережения

| Инструкция | Описание | Использование |
|------------|----------|--------------|
| `pause` | Уменьшает энергопотребление в спинлоках | В busy-wait циклах |
| `monitor` | Настройка мониторинга адреса | Для синхронизации |
| `mwait` | Ожидание события | Альтернатива hlt в многопроцессорных системах |
| `umonitor`, `umwait` | User-mode версии | |

## 18. Инструкции для криптографии

| Набор | Инструкция | Описание |
|-------|------------|----------|
| AES-NI | `aesenc`, `aesenclast` | Шифрование AES |
| | `aesdec`, `aesdeclast` | Дешифрование AES |
| | `aeskeygenassist` | Генерация ключей AES |
| SHA | `sha1rnds4`, `sha1nexte` | Хэширование SHA-1 |
| | `sha256rnds2`, `sha256msg1` | Хэширование SHA-256 |
| PCLMULQDQ | `pclmulqdq` | Умножение полиномов для GCM |

### Пример использования AES-NI:

```assembly
; Шифрование одного блока AES-128
movdqu xmm0, [plaintext]   ; Загружаем открытый текст
movdqu xmm1, [key]         ; Загружаем ключ
pxor xmm0, xmm1            ; AddRoundKey
aesenc xmm0, [key+16]      ; 9 обычных раундов
aesenc xmm0, [key+32]
; ... и так 9 раз ...
aesenclast xmm0, [key+160] ; Последний раунд
movdqu [ciphertext], xmm0  ; Сохраняем результат
```

## 19. Редко используемые, но важные инструкции

| Инструкция | Описание | Особый случай использования |
|------------|----------|----------------------------|
| `xlat` | Табличный перевод (AL = [RBX + AL]) | Быстрое преобразование символов |
| `bswap` | Обратный порядок байтов | Для работы с сетевым порядком байтов |
| `bsf`, `bsr` | Найти первый установленный бит | Для работы с битовыми массивами |
| `popcnt` | Подсчёт установленных битов | |
| `lzcnt`, `tzcnt` | Подсчёт ведущих/хвостовых нулей | |

## 20. Полный пример системной функции

```assembly
; Пример: безопасная копия памяти с проверкой границ
global memcpy_safe
memcpy_safe:
    ; RDI = dest, RSI = src, RDX = count, RCX = dest_size
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    
    ; Проверка на переполнение
    mov rax, rdi
    add rax, rdx
    cmp rax, rdi
    jb .error          ; Проверка на переполнение
    cmp rax, rdi
    jbe .check_size    ; Если dest+count не переполнился
    
.check_size:
    cmp rdx, rcx
    ja .error          ; Если count > dest_size
    
    ; Проверка перекрытия регионов
    mov rbx, rdi
    mov r12, rsi
    sub rbx, r12
    cmp rbx, rdx
    jge .copy          ; Если dest >= src+count
    neg rbx
    cmp rbx, rdx
    jge .copy          ; Если src >= dest+count
    
    ; Регионы перекрываются - используем обратный порядок
    add rdi, rdx
    add rsi, rdx
    std                ; Устанавливаем флаг направления
    rep movsb          ; Копируем в обратном порядке
    cld                ; Сбрасываем флаг направления
    jmp .success
    
.copy:
    mov rcx, rdx
    rep movsb          ; Копируем прямо
    
.success:
    xor eax, eax       ; Успех
    jmp .end
    
.error:
    mov eax, 1         ; Ошибка
    
.end:
    pop r12
    pop rbx
    pop rbp
    ret
```

---

## Заключение: Выбор правильных инструкций

### Правила выбора инструкций:

1. **Читаемость vs Производительность** — начинайте с читаемого кода, оптимизируйте позже
2. **Размер vs Скорость** — короткие инструкции часто быстрее
3. **Совместимость** — проверяйте поддержку инструкций на целевых процессорах
4. **Безопасность** — атомарные операции для многопоточного кода
5. **Специализация** — используйте SIMD для обработки данных, строковые инструкции для работы с памятью

### Полезные мнемоники:

- **REP** — повторять, пока RCX > 0
- **LOCK** — атомарная операция
- **STOS** — сохранить строку
- **MOVS** — переместить строку
- **CMPS** — сравнить строки
- **SCAS** — сканировать строку

Эти инструкции образуют базовый набор для системного программирования на x86_64. В реальном ядре ОС вы будете использовать их комбинации для реализации всех низкоуровневых механизмов.