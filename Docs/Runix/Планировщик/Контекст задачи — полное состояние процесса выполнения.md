## Аналогия из реальной жизни

Представьте, что вы читаете книгу и внезапно вам нужно переключиться на другую задачу. Чтобы позже вернуться и продолжить чтение без потери прогресса, вам нужно запомнить:

- **На какой странице** вы остановились (счётчик команд)
    
- **Какие закладки** вы поставили (регистры)
    
- **На каких строчках** сделали пометки (стек)
    
- **В каком настроении** были (флаги процессора)
    

Контекст задачи — это именно такая "фотография" состояния процессора в конкретный момент времени.

## Анатомия контекста

### **1. Программный счётчик (Instruction Pointer / Program Counter)**

- **Что это:** Адрес следующей инструкции для выполнения
    
- **Аналогия:** Номер страницы в книге, где вы остановились
    
- **Технически:** Регистр `RIP` (x86-64) или `PC` (ARM)
    
- **Важность:** Без него невозможно знать, откуда продолжить выполнение

### **2. Регистры общего назначения**

**16 регистров в x86-64, каждый со своей ролью:**

RAX - Аккумулятор (результаты операций)
RBX - Базовый регистр (указатели на данные)
RCX - Счётчик (для циклов)
RDX - Данные (второй операнд)
RSI - Источник (для операций с памятью)
RDI - Назначение (для операций с памятью)
RBP - Указатель базы стека (рамка функции)
RSP - Указатель вершины стека (текущая позиция)
R8-R15 - Дополнительные регистры (64-битные)

**Аналогия:** Это как рабочий стол с разными инструментами — у каждого своё место и назначение. Если убрать отвёртку с определённого места, вы не сможете продолжить сборку.

### **3. Сегментные регистры (только x86)**

- **CS (Code Segment)** — какой сегмент кода выполняем
    
- **DS (Data Segment)** — откуда берём данные
    
- **SS (Stack Segment)** — где находится стек
    
- **ES, FS, GS** — дополнительные сегменты данных

### **4. Регистр флагов (RFLAGS/EFLAGS)**

Битовая маска, где каждый бит — определённое состояние процессора:

Bit 0  - CF (Carry Flag) - Флаг переноса
Bit 2  - PF (Parity Flag) - Чётность результата
Bit 4  - AF (Auxiliary Carry) - Вспомогательный перенос
Bit 6  - ZF (Zero Flag) - Результат равен нулю
Bit 7  - SF (Sign Flag) - Результат отрицательный
Bit 8  - TF (Trap Flag) - Режим пошагового выполнения
Bit 9  - IF (Interrupt Flag) - Разрешены прерывания
Bit 10 - DF (Direction Flag) - Направление строковых операций
Bit 11 - OF (Overflow Flag) - Переполнение
... и ещё 20+ флагов

**Аналогия:** Это как показания приборной панели автомобиля — скорость, обороты, уровень топлива, предупреждения.

### **5. Регистры управления**

- **CR0-CR4** — контрольные регистры (режим процессора, защита памяти)
    
- **CR3** — особенно важен: содержит адрес таблицы страниц (виртуальная память)
    

### **6. Регистры отладки и производительности**

- **DR0-DR7** — точки останова
    
- **MSR** — Model-Specific Registers (разные для каждого процессора)
    

## Стек задачи — динамическая память выполнения
### **Что такое стек?**

Стек — это область памяти типа [LIFO](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) (Last In, First Out — последним пришёл, первым ушёл), которая растёт "вниз" (от старших адресов к младшим).

### **Содержимое стека:**

Высокие адреса
├── Аргументы функции 7
├── Локальные переменные функции 7
├── Адрес возврата из функции 7
├── Сохранённые регистры функции 7
├── ... 
├── Аргументы функции 2
├── Локальные переменные функции 2  
├── Адрес возврата из функции 2
├── Сохранённые регистры функции 2
├── Аргументы функции 1 (main)
├── Локальные переменные функции 1
├── Адрес возврата из функции 1
└── Сохранённые регистры функции 1
Низкие адреса

### **Фреймы стека (Stack Frames)**

## Концептуальное понимание

Представьте, что вы читаете детектив с вложенными сюжетами:

- **Глава 1:** Следователь начинает расследование (main)
    
- **Глава 2:** Вспоминает прошлое дело (вызов функции A)
    
- **Глава 3:** Внутри того дела был свидетель (вызов функции B из A)
    
- Возвращаетесь к Главе 2, потом к Главе 1
    

Каждая глава — это фрейм стека. Вы должны помнить:

- На какой странице остановились в каждой главе
    
- Какие улики собрали в каждой главе
    
- Куда вернуться после окончания вложенной главы
## Техническое определение

**Фрейм стека (stack frame, activation record)** — это область стека, выделенная для одного вызова функции. Она содержит всю информацию, необходимую для выполнения этой функции и последующего возврата к вызывающей стороне.

## Анатомия фрейма стека (x86-64)

```
Высокие адреса
┌─────────────────┐ ← Старый RBP (предыдущий фрейм)
│                 │
├─────────────────┤ ← Рамка функции (Function Prologue)
│  Сохранённый RBP│ ← Текущий RBP указывает сюда
├─────────────────┤
│  Адрес возврата │ ← RIP, куда вернуться после функции
├─────────────────┤
│  Аргумент 6     │ ← Если больше 6 аргументов, они тут
├─────────────────┤
│  Аргумент 5     │
├─────────────────┤
│   ...           │
├─────────────────┤
│  Аргумент 1     │ ← Первые 6 аргументов в регистрах, остальные тут
├─────────────────┤
│  Выравнивание   │ ← Для выравнивания по 16 байт
├─────────────────┤ ← Начало локальных переменных
│  Локальная 1    │
├─────────────────┤
│  Локальная 2    │
├─────────────────┤
│  ...            │
├─────────────────┤
│  Сохранённый RBX│ ← Регистры, которые функция будет использовать
├─────────────────┤
│  Сохранённый R12│
├─────────────────┤
│       ...       │
└─────────────────┘ ← Текущий RSP указывает сюда
Низкие адреса
```
### **Указатели стека:**

- **RSP (Stack Pointer)** — указывает на вершину стека (последний добавленный элемент)
    
- **RBP (Base Pointer)** — указывает на начало текущего фрейма
## Как это работает вместе: пример переключения

### **Ситуация:**

Задача A выполняет функцию `calculate()`, которая вызывает `sqrt()`, которая вызывает `multiply()`.

Процессор:
  RIP = 0x1234 (внутри multiply)
  RSP = 0x7FF00000 (вершина стека)
  RBP = 0x7FF00020 (начало фрейма multiply)
  RAX = 42 (результат промежуточных вычислений)
  RCX = 100 (счётчик цикла)
  RFLAGS = ... (ZF=1, последнее сравнение было равно)

Стек:
  0x7FF00000: сохранённый RBX
  0x7FF00008: локальная переменная multiply
  0x7FF00010: адрес возврата в sqrt
  0x7FF00018: аргумент multiply
  0x7FF00020: старый RBP (начало фрейма sqrt)
  ... и так далее до main
### **Сохраняем контекст:**

Операционная система копирует ВСЕ эти значения в структуру `TaskContext` задачи A.

### **Восстанавливаем контекст задачи B:**

Загружаем сохранённые значения задачи B обратно в регистры и стек.

### **Продолжаем выполнение задачи B:**

Процессор даже не знает, что его "подменили" — он продолжает с того места, где остановился B.

## Почему нужно сохранять ВСЁ?

### **Минималистский подход (не работает):**

"Давайте сохраним только RIP и RSP, остальное восстановим автоматически"

**Проблема:** Регистры содержат промежуточные результаты вычислений. Если RAX содержал результат 10-минутного расчёта, его потеря недопустима.

```
; Задача вычисляет (a * b) + (c * d)
mov rax, [a]    ; rax = a
imul rax, [b]   ; rax = a * b (промежуточный результат)
mov rbx, [c]    ; rbx = c
imul rbx, [d]   ; rbx = c * d
add rax, rbx    ; rax = (a * b) + (c * d)

; Если прервать между строками 2 и 3,
; и не сохранить RAX — результат a*b потерян навсегда
```

## Особые случаи

### **FPU/SSE/AVX регистры**

Современные процессоры имеют дополнительные регистры для чисел с плавающей точкой и векторных операций:

- **x87 FPU** — 8 регистров по 80 бит
    
- **SSE** — 16 регистров XMM0-XMM15 по 128 бит
    
- **AVX** — 16 регистров YMM0-YMM15 по 256 бит
    
- **AVX-512** — 32 регистра ZMM0-ZMM31 по 512 бит
    

Их тоже нужно сохранять! Это может быть 2+ килобайта дополнительных данных.

### **Регистры отладки**

Если задача была в режиме отладки (установлены точки останова), эти точки нужно сохранить и восстановить.

### **Регистры виртуальной памяти**

CR3 содержит таблицу страниц. При переключении задач в защищённом режиме нужно загрузить CR3 новой задачи, что вызывает переключение всего адресного пространства.

## Размер контекста: цифры
### **x86-64 (минимальный):**

```
16 регистров общего назначения × 8 байт = 128 байт
RIP + RFLAGS = 16 байт
Сегментные регистры = 8 байт
RSP + RBP = 16 байт
Итого: ~168 байт
```

### **x86-64 (реальный, с FPU):**

```
Общие регистры: 128 байт
FPU: 108 байт
SSE: 256 байт
AVX: 512 байт
Прочее: 64 байт
Итого: ~1 КБ
```

### **Стек (типичный):**

Каждая задача получает свой стек, обычно 4-8 КБ для ядерных задач и 1-4 МБ для пользовательских.

### **Стек (типичный):**

Каждая задача получает свой стек, обычно 4-8 КБ для ядерных задач и 1-4 МБ для пользовательских.

## Особенности для разных архитектур

### **x86 (32-bit)**

- Аргументы полностью в стеке
    
- Нет требования к выравниванию стека
    
- Меньше регистров → больше push/pop
    

### **x86-64 (64-bit)**

- Первые 6 аргументов в регистрах
    
- Стек должен быть выровнен по 16 байтам перед call
    
- Red zone: 128 байт ниже RSP, которые можно использовать без выделения
    

### **ARM**

- Первые 4 аргумента в регистрах R0-R3
    
- Frame pointer (R11) опционален
    
- Листовые функции (не вызывающие другие) могут не создавать фрейм
    

### **RISC-V**

- Первые 8 аргументов в регистрах a0-a7
    
- Frame pointer (s0/fp) опционален
    
- Строгие соглашения о вызовах

## Оптимизации в реальных системах

### **Lazy context switching**

Некоторые системы не сохраняют FPU/SSE регистры, пока задача не использует их. При первой попытке использования — исключение, и тогда сохраняем.

### **Copy-on-write для стека**

При создании новой задачи (fork) стек не копируется физически, а используется та же память до первой записи.

### **Выделенные регистры для частых операций**

Некоторые архитектуры (ARM) имеют shadow registers — дополнительные наборы регистров для быстрого переключения контекста прерываний.

## Практическое значение

### **Для разработчика ОС:**

Понимание контекста критично для:

- Реализации планировщика
    
- Обработки прерываний
    
- Отладчика ядра
    
- Виртуализации
    

### **Для разработчика приложений:**

- Понимание накладных расходов на переключение контекста
    
- Оптимизация глубины стека вызовов
    
- Работа с волокнами (fibers) и корутинами
    

### **Для reverse engineering:**

Анализ дампа памяти или регистров позволяет восстановить состояние программы в момент сбоя.

## Заключение

Контекст задачи — это не абстрактное понятие, а конкретный набор из сотен байтов в определённом формате, который полностью определяет состояние выполнения программы. Это "мозг" задачи, её сознание и память, вынутые из процессора и упакованные в структуру данных.

Каждое переключение контекста — это микрохирургическая операция по трансплантации сознания задачи в процессор. Одна ошибка — потерянный регистр, неправильный адрес возврата, сбитый указатель стека — и задача "сходит с ума", начиная выполнять бессмысленный код или обращаться к случайным адресам памяти.

Понимание контекста — это понимание самой сути выполнения программ: как абстрактный алгоритм превращается в конкретные переключения транзисторов, и как операционная система управляет этим превращением для тысяч задач одновременно.