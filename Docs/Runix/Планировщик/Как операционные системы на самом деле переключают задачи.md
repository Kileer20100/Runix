## Сущность многозадачности

Современные компьютеры создают иллюзию одновременного выполнения множества программ. Пользователь видит работающий текстовый редактор, открытый браузер с несколькими вкладками, работающий мессенджер и фоновые процессы — всё одновременно. Однако на одноядерном процессоре физически может выполняться только одна инструкция в каждый момент времени. Магия одновременной работы создаётся операционной системой, которая быстро переключается между задачами.

Существует два принципиально разных подхода к реализации многозадачности: кооперативный и вытесняющий. Они различаются тем, кто контролирует момент переключения между задачами.

## Кооперативная многозадачность: договорной подход

В кооперативной модели каждая задача добровольно уступает управление процессором, когда достигает точки, где может безопасно приостановиться. Это похоже на собрание, где каждый участник говорит: "Я закончил, теперь может высказаться следующий".

**Принцип работы:**  
Задачи работают до явного указания передать управление. В языках программирования это реализуется через ключевые слова вроде `yield` или конструкции async/await. Когда задача вызывает операцию ожидания (например, чтение файла или получение данных из сети), она возвращает управление планировщику.

**Преимущества:**

- Низкие накладные расходы: задача сохраняет только ту информацию, которая нужна для продолжения работы
- Простота реализации: не требуется сложной синхронизации
    
- Эффективное использование памяти: задачи могут использовать общий стек
    

**Фундаментальная проблема:**  
Если задача не уступает управление добровольно (например, попала в бесконечный цикл), вся система зависает. Это делает кооперативный подход непригодным для запуска произвольного, потенциально ненадёжного кода.

## Вытесняющая многозадачность: принудительный контроль

Вытесняющая модель даёт операционной системе абсолютную власть над переключением задач. Система решает, когда прервать выполнение текущей задачи, независимо от её желания. Это похоже на дирижёра оркестра, который указывает, когда каждому инструменту играть.

### Механизм прерываний: основа вытеснения

Сердце вытесняющего планировщика — аппаратный таймер, настроенный на регулярные прерывания. Типичная частота — от 100 до 1000 раз в секунду. Каждое прерывание — это возможность для системы принять решение о переключении задач.

**Процесс прерывания:**

1. Таймер генерирует сигнал прерывания
    
2. Процессор немедленно останавливает выполнение текущей инструкции
    
3. Сохраняется минимальный контекст (счётчик команд, регистр флагов)
    
4. Управление передаётся обработчику прерывания, определённому операционной системой
    
5. Обработчик решает, нужно ли переключать задачу

### Сохранение контекста: полная фотография состояния

Когда система решает переключить задачу, она должна сохранить полное состояние процессора в момент прерывания. Это включает:

**Регистры общего назначения** — временные данные вычислений  
**Указатель стека** — текущее положение в памяти стека  
**Счётчик команд** — адрес следующей инструкции для выполнения  
**Регистр флагов** — состояние процессора (результаты сравнений, флаги переноса)  
**Сегментные регистры** (в архитектуре x86) — информация о сегментах памяти

Это состояние сохраняется в структуре данных, называемой "контекстом задачи". Каждая задача имеет свой контекст, который служит её фотографией в момент остановки.

### Разделение стека: изоляция задач

В отличие от кооперативной модели, где задачи могут использовать общий стек, вытесняющая многозадачность требует отдельного стека для каждой задачи. Это необходимо, потому что задача может быть прервана в любой точке своего выполнения, включая глубокую вложенность вызовов функций.

Каждый стек содержит:

- Локальные переменные функций
    
- Адреса возврата из вызовов
    
- Аргументы функций
    
- Временные данные вычислений
    

Отдельные стеки обеспечивают изоляцию: задача не может случайно (или намеренно) повредить данные другой задачи.

### Алгоритмы планирования: справедливость и эффективность

Планировщик — это алгоритм, решающий, какую задачу запустить следующей. Простейший алгоритм — циклический (round-robin), где задачи выполняются по очереди. Однако реальные системы используют более сложные алгоритмы:

**Приоритетное планирование:** Важным задачам выделяется больше процессорного времени. Например, ввод с клавиатура обрабатывается с высшим приоритетом для обеспечения отзывчивости.

**Многоуровневые очереди:** Задачи группируются по характеристикам (интерактивные, фоновые, реального времени). Каждая группа имеет свою стратегию планирования.

**Квантование времени:** Каждая задача получает фиксированный отрезок времени (квант). Если задача использует весь квант, она принудительно прерывается.

**Адаптивное планирование:** Система отслеживает поведение задач и адаптирует планирование. Например, интерактивные задачи, часто ожидающие ввода, получают более высокий приоритет.

### Синхронизация: предотвращение хаоса

Когда задачи могут прерываться в любой момент, возникает проблема совместного доступа к ресурсам. Представьте, что задача начала изменять сложную структуру данных, была прервана, а другая задача попыталась прочитать эти данные в промежуточном состоянии.

Для решения этой проблемы используются механизмы синхронизации:

**[[Семафоры — механизм ограничения параллельного доступа к ресурсам]]** — счётчики, ограничивающие количество задач, одновременно использующих ресурс

**[[Атомарные операции]]** — базовые неделимые операции процессора, обеспечивающие безопасный доступ к общим данным без использования блокировок. В отличие от мьютексов, которые приостанавливают задачу при недоступности ресурса, атомарные операции используют аппаратную поддержку процессора для гарантии целостности данных.

**Условные переменные** — позволяют задачам ждать определённых условий

**Спинлоки** — активное ожидание освобождения ресурса

Эти механизмы координируют доступ к общим ресурсам, предотвращая конфликты и повреждение данных.

### Многопроцессорные системы: параллелизм в действии

Современные процессоры имеют несколько ядер, что позволяет действительно параллельное выполнение задач. Это добавляет новые сложности:

**Балансировка нагрузки:** Распределение задач между ядрами для равномерной загрузки

**Аффинитизация:** Привязка задач к определённым ядрам для лучшего использования кэша

**Межъядерная синхронизация:** Координация между задачами, выполняющимися на разных ядрах

**Миграция задач:** Перемещение задач между ядрами для оптимизации производительности

В таких системах планировщик становится распределённым: каждое ядро имеет локальную очередь задач, но может "красть" задачи у других ядер при недогрузке.

### Обработка блокировок: эффективное ожидание

Задачи часто блокируются, ожидая внешних событий: завершения операции ввода-вывода, освобождения ресурса, истечения таймера. Примитивное ожидание (активный опрос) расточительно тратит процессорное время.

Умный планировщик переводит заблокированные задачи в состояние ожидания и удаляет их из очереди готовых к выполнению. Когда событие происходит (например, данные пришли по сети), задача возвращается в очередь готовых.

Это реализуется через механизм "пробуждения": драйвер устройства или системный вызов уведомляет планировщик, что задача может продолжить работу.

### Преимущества вытесняющей многозадачности

**Надёжность:** Одна некорректная задача не может заблокировать всю систему. Даже если программа зависла в бесконечном цикле, система продолжает работать.

**Справедливость:** Все задачи получают процессорное время пропорционально своим приоритетам.

**Изоляция:** Задачи не могут влиять на выполнение друг друга (за исключением явного взаимодействия).

**Поддержка реального времени:** Возможность гарантировать время реакции для критических задач.

**Безопасность:** Возможность ограничивать права доступа задач к ресурсам.

### Цена вытеснения

Вытесняющая многозадачность не бесплатна:

**Накладные расходы:** Сохранение и восстановление контекста требует времени. Частые переключения могут снизить общую производительность.

**Использование памяти:** Каждой задаче требуется собственный стек, что увеличивает потребление памяти.

**Сложность:** Синхронизация доступа к общим ресурсам требует аккуратного программирования.

**Непредсказуемость:** Задача может быть прервана в любой момент, что усложняет отладку и анализ производительности.

### Эволюция планировщиков

Современные планировщики — результат десятилетий эволюции:

**Ранние системы:** Простые циклические алгоритмы

**UNIX:** Многоуровневые очереди с обратной связью

**Windows NT:** Приоритетное планирование с поддержкой реального времени

**Linux O(1) и CFS:** Алгоритмы, обеспечивающие справедливость при миллионах задач

**Современные исследования:** Планировщики, учитывающие энергопотребление, тепловыделение, использование кэша

### Практическое значение

Понимание работы вытесняющего планировщика важно не только разработчикам операционных систем:

**Разработчикам приложений:** Понимание, как их код взаимодействует с планировщиком, помогает писать эффективные и отзывчивые программы

**Системным администраторам:** Настройка параметров планирования для оптимальной работы системы

**Разработчикам встроенных систем:** Создание систем реального времени с предсказуемым поведением

**Исследователям:** Понимание фундаментальных ограничений и возможностей многозадачности

## Заключение

Вытесняющая многозадачность — фундаментальная технология, позволяющая современным операционным системам одновременно выполнять множество задач, обеспечивая надёжность, справедливость и отзывчивость. Это сложный компромисс между производительностью, использованием ресурсов и функциональностью.

От аппаратных прерываний таймера до сложных алгоритмов планирования, от сохранения контекста до синхронизации между ядрами — каждый компонент вытесняющего планировщика решает конкретную проблему, возникающую при попытке заставить один процессор выполнять работу многих.

Понимание этих механизмов — ключ к пониманию того, как работают современные вычислительные системы, и как создавать программное обеспечение, эффективно взаимодействующее с этими системами.