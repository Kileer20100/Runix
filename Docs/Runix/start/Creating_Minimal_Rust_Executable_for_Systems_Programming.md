## Создание минимального исполняемого файла на Rust для системного программирования
## Введение

Первый шаг в создании операционной системы на Rust — разработка исполняемого файла, который не зависит от стандартной библиотеки и окружения операционной системы. Такой файл может выполняться напрямую на "голом железе", без поддержки со стороны существующей ОС. Это фундаментальное требование для ядра операционной системы, которое само должно предоставлять базовые сервисы, а не полагаться на них.

В отличие от обычных программ Rust, которые автоматически используют стандартную библиотеку и среду выполнения, системное программирование требует явного отказа от этих абстракций. Это позволяет получить полный контроль над аппаратным обеспечением, но также накладывает ответственность за реализацию базовых механизмов, которые в обычных условиях предоставляются операционной системой.
## Отказ от стандартной библиотеки

Стандартная библиотека Rust предоставляет удобные абстракции, но большинство из них зависят от функций операционной системы: файловые операции, сетевое взаимодействие, управление памятью через кучу, многопоточность. Для ядра ОС эти зависимости неприемлемы, поскольку само ядро должно предоставлять эти сервисы.

Для отключения стандартной библиотеки используется атрибут `#![no_std]`:
```rust
#![no_std]

// Больше нет доступа к std::*
// Но core и alloc по-прежнему доступны
```
Этот атрибут указывает компилятору, что программа не должна связываться со стандартной библиотекой. Однако сохраняется доступ к библиотеке `core`, которая содержит фундаментальные типы и трейты, не зависящие от ОС: `Option`, `Result`, итераторы, примитивные типы и т.д.

## Обработка паники

В обычных программах Rust паника вызывает распечатку сообщения об ошибке и раскрутку стека (unwinding). Оба этих механизма зависят от стандартной библиотеки и операционной системы. В системном программировании необходимо предоставить собственную реализацию:
```rust
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    // В ядре ОС мы не можем полагаться на стандартные
    // механизмы обработки паники
    // Здесь можно, например, вывести сообщение на экран
    // или перезагрузить систему
    loop {} // Бесконечный цикл как простейшая заглушка
}
```
Паника в системном коде должна рассматриваться как критическая ошибка, часто требующая остановки системы или перезагрузки.
## Отказ от раскрутки стека

Раскрутка стека при панике — сложный процесс, требующий поддержки со стороны операционной системы. Для системного программирования обычно используется стратегия "abort" — немедленное прерывание выполнения без очистки ресурсов:
```rust
# Cargo.toml
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```
Это уменьшает размер исполняемого файла и устраняет зависимость от библиотек раскрутки стека.
## Переопределение точки входа

В обычной программе Rust выполнение начинается с функции `main`, которая вызывается средой выполнения. В системном программировании среда выполнения отсутствует, поэтому необходимо определить собственную точку входа:
```rust
#![no_main] // Отключаем стандартную точку входа

#[no_mangle] // Сохраняем имя функции для компоновщика
pub extern "C" fn _start() -> ! {
    // Эта функция вызывается напрямую загрузчиком
    // Она не должна возвращаться
    loop {}
}
```
Имя `_start` является соглашением, ожидаемым большинством загрузчиков и компоновщиков. Функция помечается как расходящаяся (`-> !`), поскольку после её выполнения системе нечего делать — либо управление передаётся другим компонентам, либо система останавливается.


## Решение проблем компоновщика

При компиляции независимого исполняемого файла возникают ошибки компоновщика, поскольку он ожидает наличия стандартной среды выполнения C (crt0). Существует два основных подхода решения этой проблемы:

### Компиляция для "голого железа"
```
cargo build --target thumbv7em-none-eabihf
```
Использование целевой платформы без операционной системы (с `none` в названии) указывает компоновщику не ожидать стандартных библиотек.

### Создание кастомной целевой платформы
Для x86_64 архитектуры создаётся файл `x86_64-unknown-none.json`:
```rust
{
  "llvm-target": "x86_64-unknown-none",
  "data-layout": "e-m:e-i64:64-f80:128-n8:16:32:64-S128",
  "arch": "x86_64",
  "target-endian": "little",
  "target-pointer-width": "64",
  "target-c-int-width": "32",
  "os": "none",
  "executables": true,
  "linker-flavor": "ld.lld",
  "linker": "rust-lld",
  "panic-strategy": "abort",
  "disable-redzone": true,
  "features": "-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2"
}
```

## Минимальный пример
```rust
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[no_mangle]
pub extern "C" fn _start() -> ! {
    // Это минимальный исполняемый файл
    // На практике здесь будет инициализация
    // и запуск основных компонентов системы
    loop {}
}
```
Соответствующий `Cargo.toml`:
```rust
[package]
name = "kernel"
version = "0.1.0"
edition = "2021"

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"

[dependencies]
# Пока пусто, позже добавятся необходимые крейты
```

## Значение для проекта Runix
Создание минимального исполняемого файла — первый и необходимый шаг для Runix. Он демонстрирует:
1. **Независимость от ОС**: Получен код, который может выполняться без поддержки существующей операционной системы.
    
2. **Контроль над исполнением**: Определена собственная точка входа, с которой начинается выполнение системы.
    
3. **Минимальные зависимости**: Устранены зависимости от стандартных библиотек и сред выполнения.
    
4. **Фундамент для расширения**: На этой основе можно строить более сложные компоненты: менеджер памяти, обработчики прерываний, драйверы устройств.
Этот минимальный исполняемый файл, хотя и не делает ничего полезного сам по себе, служит доказательством концепции и основой, на которой будет построена вся остальная система. Каждый следующий компонент Runix будет добавляться к этому фундаменту, постепенно превращая бесконечный цикл в полнофункциональную операционную систему.

Следующий шаг — настройка компоновки для x86_64 архитектуры и добавление возможности вывода информации на экран, что позволит наблюдать за выполнением системы и отлаживать её по мере развития.

[Создание минимального ядра на Rust Практический старт для Runix](Building_Minimal_Rust_Kernel_Practical_Start_Runix.md)