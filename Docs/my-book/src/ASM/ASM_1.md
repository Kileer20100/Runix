# Ассемблер с нуля: Язык процессора для всех

## Что такое ассемблер?

Ассемблер — это язык, с которым ты разговариваешь не с компьютером через привычные абстракции, а напрямую с его сердцем — процессором.

Если обычный язык программирования — это строительный план, то ассемблер — это инструкции для каждого кирпича.

## Представим мир по уровням

1. **Машинный код: 11001001 10101010**
   Это секретный шифр для процессора. Он понимает только такие комбинации 0 и 1. Человек тут бессилен — читать и писать напрямую почти невозможно.

2. **Ассемблер: mov rax, 42**
   Это язык для человека, понятный и точный. Каждая команда — шаг процессора: взять число, положить в регистр, сложить, переслать куда нужно. Ассемблер — это твой личный мост к железу.

3. **Язык высокого уровня: let x = 42;**
   Ты говоришь: «хочу, чтобы это число было в переменной». Компилятор сам решает, как разложить это на команды процессора. Это удобно, но ты теряешь контроль над тем, что реально делает процессор.

## Живой пример

Представь, что процессор — это мастер, который строит дом:

- **На высокоуровневом языке** ты просто говоришь:
  ```
  «Построй дом с 2 этажами и балконом».
  ```
  Мастер сам решает, в каком порядке класть кирпичи.

- **На ассемблере** ты говоришь:
  ```
  «Возьми кирпич №1, положи раствор, кирпич №2, кирпич №3…»
  ```
  Здесь нет «приблизительно» — каждая команда выполняется точно так, как ты написал.

- **Машинный код** — это невидимые руки мастера, он просто делает:
  ```
  11001001 10101010
  ```
  Ты не знаешь, какой кирпич куда попадёт, но процессор всё выполняет мгновенно.

---

## 1. Регистры процессора: Внутренние карманы

### Что такое регистры?

Регистры — это сверхбыстрые ячейки памяти внутри самого процессора. Представьте, что у процессора есть 16 карманов, куда он может моментально класть и доставать данные.

### Основные регистры x86_64:

**ГЛАВНЫЕ КАРМАНЫ:**
- `rax` - Основной рабочий карман (результаты операций)
- `rbx` - Вспомогательный карман (хранение данных)
- `rcx` - Карман-счётчик (для циклов)
- `rdx` - Дополнительный карман (расширяет rax)

**КАРМАНЫ ДЛЯ ПЕРЕДАЧИ ДАННЫХ:**
- `rdi` - Первый аргумент функции
- `rsi` - Второй аргумент функции
- `r8`, `r9`, `r10`, `r11` - Третий, четвёртый и так далее

**КАРМАНЫ ДЛЯ СТЕКА:**
- `rsp` - Указывает на верхнюю тарелку в стопке
- `rbp` - Указывает на дно текущей стопки тарелок

**ОСТАЛЬНЫЕ КАРМАНЫ:**
- `r12`, `r13`, `r14`, `r15` - Дополнительные места для хранения

### Как работают регистры:

Каждый регистр — это 64 бита (8 байтов) быстрой памяти. Для сравнения: обращение к обычной памяти — как сходить в кладовку, а к регистру — как взять со стола.

---

## 2. Простейшие операции с регистрами

### Пример 1: Сложение двух чисел

```assembly
; Загружаем числа в регистры
mov rax, 10    ; Кладём 10 в карман rax
mov rbx, 20    ; Кладём 20 в карман rbx

; Складываем
add rax, rbx   ; rax = rax + rbx = 10 + 20 = 30

; Теперь в rax лежит 30
```

### Пример 2: Перемножение

```assembly
mov rax, 5     ; Первое число
mov rbx, 6     ; Второе число
mul rbx        ; Умножаем rax на rbx, результат в rax
; Теперь в rax лежит 30
```

---

## 3. Регистры vs Память: Скорость

### Иерархия скорости:

1. **РЕГИСТРЫ (1 такт)** → Мгновенно, как мысль
2. **КЭШ L1 (3-4 такта)** → Как достать из кармана куртки
3. **КЭШ L2 (10 тактов)** → Как сходить в соседнюю комнату
4. **КЭШ L3 (30 тактов)** → Как сходить на другой этаж
5. **ОПЕРАТИВНАЯ ПАМЯТЬ (100+)** → Как сходить в магазин на улице
6. **ДИСК (миллионы тактов)** → Как съездить в другой город

### Почему регистры быстрее:

- На кристалле — физически встроены в процессор
- Нет шин — не нужно передавать данные по проводам
- Параллельный доступ — можно работать со многими сразу

### Пример разницы:

```assembly
; БЫСТРО: работа только с регистрами
mov rax, rbx    ; 1 такт
add rax, rcx    ; 1 такт
; Итого: 2 такта

; МЕДЛЕННО: работа с памятью
mov rax, [адрес1] ; 100+ тактов (идём в память)
add rax, [адрес2] ; ещё 100+ тактов
; Итого: 200+ тактов
```

---

## 4. Соглашения о вызовах: Как функции общаются

В ассемблере есть правила, как функции передают друг другу аргументы. Для Linux/macOS используется System V AMD64 ABI:

### Правила передачи аргументов:

- **ПЕРВЫЙ аргумент** → RDI
- **ВТОРОЙ аргумент** → RSI
- **ТРЕТИЙ аргумент** → RDX
- **ЧЕТВЁРТЫЙ** → RCX
- **ПЯТЫЙ** → R8
- **ШЕСТОЙ** → R9
- **Остальные** → в стек

### Пример функции сложения:

```assembly
global add_numbers
add_numbers:
    ; RDI содержит первое число
    ; RSI содержит второе число
    mov rax, rdi    ; Копируем первое число в RAX
    add rax, rsi    ; Прибавляем второе число
    ret             ; Возвращаем результат в RAX
```

### Как это работает из другой программы:

```assembly
; Подготовка аргументов
mov rdi, 10    ; Первый аргумент = 10
mov rsi, 20    ; Второй аргумент = 20

; Вызов функции
call add_numbers

; Теперь в RAX лежит 30
```

---

## 5. Работа с памятью: Доступ к данным

### Синтаксис доступа к памяти:

```assembly
; Чтение из памяти
mov rax, [адрес]    ; Прочитать 8 байтов по адресу в RAX

; Запись в память  
mov [адрес], rbx    ; Записать RBX по адресу

; Работа с массивами
mov rax, [массив + индекс*размер]
```

### Пример: Сумма элементов массива

```assembly
global sum_array
sum_array:
    ; RDI = адрес массива
    ; RSI = количество элементов
    xor rax, rax     ; Обнуляем сумму (быстрее чем mov rax, 0)
    test rsi, rsi    ; Проверяем, не пустой ли массив
    jz .done         ; Если пустой, выходим
    
.loop:
    add rax, [rdi]   ; Добавляем текущий элемент к сумме
    add rdi, 8       ; Переходим к следующему элементу (8 байт для 64-битного)
    dec rsi          ; Уменьшаем счётчик
    jnz .loop        ; Если не ноль, продолжаем
    
.done:
    ret
```

---

## 6. Стек: Временное хранилище

### Что такое стек?

Стек — это область памяти, работающая по принципу "последним пришёл — первым ушёл" (LIFO). Как стопка тарелок.

### Основные операции:

```assembly
push rax   ; Положить RAX на вершину стека
pop rbx    ; Снять значение с вершины стека в RBX

; Эквивалентно:
; push rax = sub rsp, 8 + mov [rsp], rax
; pop rbx  = mov rbx, [rsp] + add rsp, 8
```

### Пример использования стека в функции:

```assembly
global calculate
calculate:
    push rbp        ; Сохраняем старый RBP
    mov rbp, rsp    ; Устанавливаем новый базовый указатель
    
    push rbx        ; Сохраняем RBX (он должен сохраняться)
    push r12        ; Сохраняем R12
    
    ; ... тело функции ...
    
    pop r12         ; Восстанавливаем R12
    pop rbx         ; Восстанавливаем RBX
    
    pop rbp         ; Восстанавливаем RBP
    ret             ; Возвращаемся
```

---

## 7. Условные переходы и циклы

### Флаги процессора:

Процессор хранит результаты сравнений в специальных флагах:

- **ZF (Zero Flag)** — установлен, если результат равен нулю
- **CF (Carry Flag)** — установлен, если было переполнение
- **SF (Sign Flag)** — установлен, если результат отрицательный

### Инструкции сравнения:

```assembly
cmp rax, rbx    ; Сравнить RAX и RBX, установить флаги
test rax, rax   ; Проверить RAX на ноль (быстрее чем cmp rax, 0)
```

### Условные переходы:

```assembly
je  метка    ; Перейти если равны (ZF=1)
jne метка    ; Перейти если не равны (ZF=0)
jg  метка    ; Перейти если больше
jl  метка    ; Перейти если меньше
jge метка    ; Перейти если больше или равно
jle метка    ; Перейти если меньше или равно
```

### Пример цикла:

```assembly
mov rcx, 10      ; Счётчик цикла = 10
mov rax, 0       ; Сумма = 0

.loop_start:
    add rax, rcx     ; Добавляем текущее значение
    dec rcx          ; Уменьшаем счётчик
    jnz .loop_start  ; Продолжаем, если не ноль
    
; Теперь в RAX сумма чисел от 1 до 10 = 55
```

---

## 8. Работа с устройствами: Порты ввода-вывода

### Порты vs Память:

- **Память** — общее хранилище данных
- **Порты** — специальные адреса для общения с устройствами

### Команды работы с портами:

```assembly
in al, dx     ; Прочитать байт из порта DX в AL
out dx, al    ; Записать байт из AL в порт DX

in ax, dx     ; Прочитать слово (16 бит)
in eax, dx    ; Прочитать двойное слово (32 бита)
```

### Пример: Ждать нажатия клавиши

```assembly
wait_for_key:
    mov dx, 0x64        ; Порт статуса клавиатуры
    in al, dx           ; Читаем статус
    test al, 1          ; Проверяем бит "данные готовы"
    jz wait_for_key     ; Если нет, ждём дальше
    
    mov dx, 0x60        ; Порт данных клавиатуры
    in al, dx           ; Читаем код клавиши
    ; Теперь в AL лежит код нажатой клавиши
```

---

## 9. Оптимизация: Лучшие практики

### 1. Используйте короткие формы:

```assembly
; Вместо:
mov rax, 0
; Пишите:
xor rax, rax    ; Быстрее и короче

; Вместо:
cmp rax, 0
; Пишите:
test rax, rax   ; Быстрее
```

### 2. Избегайте лишних обращений к памяти:

```assembly
; ПЛОХО:
mov rax, [mem1]
add rax, [mem2]
mov [mem3], rax

; ХОРОШО:
mov rax, [mem1]
add rax, [mem2]
; ... делаем ещё что-то с rax ...
mov [mem3], rax
```

### 3. Используйте подходящие регистры:

```assembly
; Для счётчиков циклов — RCX
mov rcx, 100
loop_start:
    ; ...
    loop loop_start    ; Автоматически уменьшает RCX и прыгает
    
; Для умножения/деления — RAX, RDX
mov rax, число
mul множитель         ; Результат в RDX:RAX
```

---

## 10. Отладка и поиск ошибок

### Частые ошибки:

#### Забыли сохранить регистры:

```assembly
; ОШИБКА:
my_function:
    mov rbx, важное_значение
    ; ... используем rbx ...
    ret  ; rbx изменился!
    
; ПРАВИЛЬНО:
my_function:
    push rbx          ; Сохраняем
    ; ... используем rbx ...
    pop rbx           ; Восстанавливаем
    ret
```

#### Путаница с размерами:

```assembly
mov rax, [массив]     ; Читает 8 байтов
mov eax, [массив]     ; Читает 4 байта
mov ax, [массив]      ; Читает 2 байта
mov al, [массив]      ; Читает 1 байт
```

#### Неверные адреса:

```assembly
; ОШИБКА: забыли квадратные скобки
mov rax, адрес      ; Загружает САМ АДРЕС в RAX
mov rax, [адрес]    ; Загружает ДАННЫЕ ПО АДРЕСУ в RAX
```

---

## 11. Пример полной программы на NASM

### Программа: Вычисление факториала

```assembly
section .data
    result_msg db "Factorial: ", 0
    newline db 10, 0

section .bss
    buffer resb 20    ; Буфер для вывода числа

section .text
    global _start

; Функция вычисления факториала
; Вход: RDI = число
; Выход: RAX = факториал
factorial:
    cmp rdi, 1
    jle .base_case
    push rdi
    dec rdi
    call factorial
    pop rdi
    mul rdi
    ret
.base_case:
    mov rax, 1
    ret

; Точка входа
_start:
    mov rdi, 5        ; Вычисляем 5!
    call factorial
    
    ; Теперь в RAX лежит 120 (5! = 120)
    
    ; Завершаем программу
    mov rax, 60       ; Системный вызов exit
    xor rdi, rdi      ; Код выхода 0
    syscall
```

---

## 12. Зачем всё это нужно?

### Когда использовать ассемблер:

- Разработка операционных систем — прямое управление железом
- Драйверы устройств — общение с конкретным оборудованием
- Критичные к производительности участки — игры, шифрование, компрессия
- Встраиваемые системы — микроконтроллеры с ограниченными ресурсами
- Обратное проектирование — анализ чужого кода
- Обучение — понимание, как работает компьютер на самом деле

### Когда НЕ использовать ассемблер:

- Обычные приложения — современные компиляторы пишут код лучше людей
- Веб-разработка — бессмысленно
- Быстрая разработка прототипов — слишком медленно
- Кроссплатформенные проекты — код для x86 не работает на ARM

---

## Заключение: Ассемблер — это сила

Ассемблер даёт вам полный контроль над компьютером. Вы становитесь архитектором, который напрямую общается с процессором, памятью и устройствами.

### Что дальше?

1. **Практика** — пишите маленькие программы, разбирайте их по шагам
2. **Изучайте системные вызовы** — как программы общаются с ОС
3. **Смотрите код компиляторов** — как высокоуровневые языки превращаются в ассемблер
4. **Экспериментируйте** — пробуйте разные оптимизации, смотрите на скорость

**Помните:** каждая программа, которую вы запускаете, в конечном итоге становится ассемблером. Теперь вы знаете, что происходит под капотом.